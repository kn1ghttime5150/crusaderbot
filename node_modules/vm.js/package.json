{
  "_args": [
    [
      "vm.js",
      "/home/crusaderbot"
    ]
  ],
  "_from": "vm.js@latest",
  "_id": "vm.js@0.0.6",
  "_inCache": true,
  "_installable": true,
  "_location": "/vm.js",
  "_npmUser": {
    "email": "tpadilha84@gmail.com",
    "name": "tarruda"
  },
  "_npmVersion": "1.3.8",
  "_phantomChildren": {},
  "_requested": {
    "name": "vm.js",
    "raw": "vm.js",
    "rawSpec": "",
    "scope": null,
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/vm.js/-/vm.js-0.0.6.tgz",
  "_shasum": "d627f9a27cd6b9111a408514aa26c9a9d89a02af",
  "_shrinkwrap": null,
  "_spec": "vm.js",
  "_where": "/home/crusaderbot",
  "author": {
    "email": "tpadilha84@gmail.com",
    "name": "Thiago de Arruda"
  },
  "bugs": {
    "url": "https://github.com/tarruda/vm.js/issues"
  },
  "dependencies": {
    "esprima": "git://github.com/tarruda/esprima.git#harmony"
  },
  "description": "Javascript bytecode compiler/virtual machine implemented in pure coffeescript",
  "devDependencies": {
    "benchmark": "~1.0.0",
    "expect.js": "~0.2.0",
    "grunt": "~0.4.1",
    "grunt-coffee-build": "~1.4.5",
    "grunt-coffeelint": "0.0.7",
    "grunt-contrib-clean": "~0.5.0",
    "grunt-contrib-connect": "~0.3.0",
    "grunt-contrib-livereload": "~0.1.2",
    "grunt-contrib-uglify": "~0.2.2",
    "grunt-contrib-watch": "~0.5.1",
    "grunt-mocha-debug": "0.0.3",
    "grunt-release": "~0.5.1",
    "microtime": "~0.4.0",
    "mocha": "~1.9.0",
    "source-map-support": "~0.2.1"
  },
  "directories": {},
  "dist": {
    "shasum": "d627f9a27cd6b9111a408514aa26c9a9d89a02af",
    "tarball": "https://registry.npmjs.org/vm.js/-/vm.js-0.0.6.tgz"
  },
  "engines": {
    "node": ">=0.8.0"
  },
  "homepage": "https://github.com/tarruda/vm.js#readme",
  "keywords": [
    "coroutine",
    "fiber",
    "generator",
    "harmony",
    "javascript-sandbox",
    "sandbox",
    "virtual-machine",
    "vm"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/tarruda/vm.js/blob/master/LICENSE-MIT"
    }
  ],
  "main": "./build/nodejs/src/index",
  "maintainers": [
    {
      "name": "tarruda",
      "email": "tpadilha84@gmail.com"
    }
  ],
  "name": "vm.js",
  "optionalDependencies": {},
  "readme": "# vm.js\n\n> Javascript bytecode compiler/vm written in coffeescript\n\n## Installation\n```shell\nnpm install vm.js\n```\n\n### Overview\n\nvm.js implements a ECMAScript virtual machine that can be used from any\nECMAScript3-compatible environment. Eventually it will provide a complete\nECMAScript 6 environment(for now only some features are supported)\n\nHere are some possible use cases:\n\n- Simple in-process javascript sandbox\n- Async-to-sync API adapter using fibers(lightweight in-process threads)\n- Use new ECMAScript features in very old browsers\n\n\n### Usage\n\nThe main API can be accessed through Vm instances. Each Vm is indirectly\nassociated with a global object(through a Realm) and is isolated from other\nVms.\n\nStart by creating a new instance:\n\n```js\n> Vm = require('vm.js') \n> vm = new Vm()\n```\n\nEvaluate simple expressions:\n```js\n> vm.eval('40 + 2')\n42\n> vm.eval('[a, b, c] = [1, 2, 3]') // Harmony destructuring assignment\n[1, 2, 3]\n> vm.realm.global.a\n1\n> vm.realm.global.b\n2\n> vm.realm.global.c\n3\n```\n\nCompile programs and run later\n```js\n// pass filename as second argument for stack traces/debugging\n> script = Vm.compile('2 + 2', 'sum.js')\n> vm.run(script)\n4\n```\n\nCompiled scripts can be serialized/deserialized to/from JSON-friendly\nstructures:\n```js\n> scriptObj = script.toJSON()\n> serializedScript = JSON.stringify(scriptObj)\n> deserializedScript = Vm.fromJSON(JSON.parse(serializedScript))\n> vm.run(deserializedScript)\n```\n\nExpose objects to be used by code running inside the Vm\n```js\n> vm.realm.global.factorial = function factorial(n) { return n > 1 ? factorial(n - 1) * n : 1 }\n> vm.eval('factorial(5)')\n120\n```\n\nThe inverse also works:\n```js\n> vm.eval('function factorial(n) { return n > 1 ? factorial(n - 1) * n : 1 }')\n> vm.realm.global.factorial(5)\n120\n```\n\nReturn values asynchronously using fiber pause/resume:\n```js\n// created a paused fiber from compiled code\nfiber = vm.createFiber(Vm.compile('user = null; user = fetchAsync(\"/users/1\");'))\nvm.realm.global.fetchAsync = function(url) {\n  fiber.pause() // pause execution\n  $.get(url, function(data) {\n    // user === null\n    fiber.setReturnValue(data)\n    fiber.resume()\n    // user === data\n  });\n}\n// start fiber\nfiber.run()\n```\n\nBuiltin objects are exposed, but each Vm instance uses a copy-on-write\nalgorithm to maintain its own state of builtin globals:\n```js\n> vm.eval('Object.prototype') === Object.prototype\ntrue\n> vm.eval('Object.prototype.bark = function() { return \"bark!\" }')\n> vm.eval('[].bark()')\n'bark!'\n> 'bark' in Object.prototype\nfalse\n```\n\nIts possible to provide a instruction timeout(maximum number of instructions a\nfiber can execute).\n```js\n> vm.eval(\"i = 0; while (true) i++\", 'timeout.js', 500)\nTimeoutError: Script timed out\n    at timeout.js:1:20\n```\nThe TimeoutError has a 'fiber' property that references the paused fiber(it can\nbe resumed, optionally passing another timeout to the 'resume' method).\n\n\nAs shown above, some harmony features are available. Here's a generator\nexample:\n```js\n> vm.eval(\n'function* fib() {' +\n  'var i = 0, j = 1, t;' +\n  'while (true) {' +\n    'yield i;' +\n    't = i;' +\n    'i = j;' +\n    'j += t;' +\n  '}' +\n'}')\n> vm.eval('l = []')\n> vm.eval('for (let i of fib()) {if (l.length > 10) break; l.push(i)}')\n> vm.eval('l')\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n```\n\nLike normal functions, the 'fib' generator can be used outside a vm instance:\n```js\n> g = vm.realm.global.fib(); l = [];\n> while (l.length < 11) l.push(g.next())\n> l\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n```\n\nSee more examples and supported features [here](https://github.com/tarruda/vm.js/blob/master/test/vm.coffee).\n\n### Comments\n\nThis was inspired by [Continuum](https://github.com/Benvie/continuum) which is\na ECMAScript 6 virtual machine implemented in pure javascript. I wrote this\nbecause I wanted a smaller codebase(less than 5k lines of coffeescript code)\n and seamless integration with the host virtual machine(no need to call strange\ninternal methods to access objects manipulated by the vm).\n\nFor parsing source code this library uses the\n[esprima parser](https://github.com/ariya/esprima).\n\nThere are about 200 acceptance tests that are run twice: once inside\na normal Vm and again inside a self-hosted Vm(think about\nthe movie 'Inception' for an easy analogy). That means it is capable\nof running moderately complex javascript code(since it runs itself plus\nthe esprima parser), so it should be stable enough for most uses.\n",
  "readmeFilename": "README.mkd",
  "repository": {
    "type": "git",
    "url": "git://github.com/tarruda/vm.js.git"
  },
  "version": "0.0.6"
}
