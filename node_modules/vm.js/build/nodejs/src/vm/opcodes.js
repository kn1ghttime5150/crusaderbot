(function() {
  var ArrayIterator, Counter, Fiber, Op, OpcodeClassFactory, RegExpProxy, Scope, StopIteration, Visitor, VmEvalError, VmReferenceError, VmTypeError, WithScope, calculateOpcodeFactor, call, callArrayConstructor, callDateConstructor, callRegExpConstructor, callm, create, createFunction, createGenerator, createNativeInstance, debug, defProp, esprima, hasProp, opcodes, ret, throwErr, _ref, _ref1, _ref2, _ref3,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  esprima = require('esprima');

  Visitor = require('../ast/visitor');

  _ref = require('../runtime/builtin'), StopIteration = _ref.StopIteration, ArrayIterator = _ref.ArrayIterator;

  _ref1 = require('../runtime/util'), defProp = _ref1.defProp, hasProp = _ref1.hasProp, create = _ref1.create;

  _ref2 = require('../runtime/errors'), VmTypeError = _ref2.VmTypeError, VmEvalError = _ref2.VmEvalError, VmReferenceError = _ref2.VmReferenceError;

  RegExpProxy = require('../runtime/regexp_proxy');

  _ref3 = require('./thread'), Fiber = _ref3.Fiber, Scope = _ref3.Scope, WithScope = _ref3.WithScope;

  OpcodeClassFactory = (function() {
    var classFactory, id;
    id = 0;
    classFactory = function(name, fn, calculateFactor) {
      var OpcodeClass;
      OpcodeClass = (function() {
        var constructor;
        if (typeof eval !== 'function' || (typeof (constructor = eval("(function " + name + "(args) { if (args) this.args = args; })")) !== 'function')) {
          constructor = function(args) {
            if (args) {
              this.args = args;
            }
          };
          constructor.name = name;
        }
        constructor.prototype.id = id++;
        constructor.prototype.name = name;
        constructor.prototype.exec = fn;
        if (calculateFactor) {
          constructor.prototype.calculateFactor = calculateFactor;
        } else {
          constructor.prototype.factor = calculateOpcodeFactor(fn);
          constructor.prototype.calculateFactor = function() {
            return this.factor;
          };
        }
        return constructor;
      })();
      return OpcodeClass;
    };
    return classFactory;
  })();

  Counter = (function(_super) {
    __extends(Counter, _super);

    function Counter() {
      this.factor = 0;
      this.current = 0;
    }

    Counter.prototype.CallExpression = function(node) {
      var name;
      node = Counter.__super__.CallExpression.call(this, node);
      if (node.callee.type === 'MemberExpression') {
        if (node.callee.property.type === 'Identifier') {
          name = node.callee.property.name;
        } else if (node.callee.property.type === 'Literal') {
          name = node.callee.property.value;
        } else {
          throw new Error('assert error');
        }
        if (name === 'push') {
          this.current++;
        } else if (name === 'pop') {
          this.current--;
        }
        this.factor = Math.max(this.factor, this.current);
      }
      return node;
    };

    return Counter;

  })(Visitor);

  calculateOpcodeFactor = function(opcodeFn) {
    var ast, counter;
    ast = esprima.parse("(" + (opcodeFn.toString()) + ")");
    counter = new Counter();
    counter.visit(ast);
    return counter.factor;
  };

  Op = function(name, fn, factorFn) {
    return OpcodeClassFactory(name, fn, factorFn);
  };

  opcodes = [
    Op('POP', function(f, s, l) {
      return s.pop();
    }), Op('DUP', function(f, s, l) {
      return s.push(s.top());
    }), Op('SWAP', function(f, s, l) {
      var bot, top;
      top = s.pop();
      bot = s.pop();
      s.push(top);
      return s.push(bot);
    }), Op('RET', function(f, s, l) {
      return ret(f);
    }), Op('RETV', function(f, s, l) {
      f.fiber.rv = s.pop();
      return ret(f);
    }), Op('PAUSE', function(f, s) {
      return f.paused = true;
    }), Op('YIELD', function(f, s) {
      f.fiber.yielded = s.pop();
      return f.fiber.pause();
    }), Op('THROW', function(f, s, l) {
      return throwErr(f, s.pop());
    }), Op('ENTER_GUARD', function(f) {
      return f.guards.push(f.script.guards[this.args[0]]);
    }), Op('EXIT_GUARD', function(f) {
      var currentGuard, specifiedGuard;
      currentGuard = f.guards[f.guards.length - 1];
      specifiedGuard = f.script.guards[this.args[0]];
      if (specifiedGuard === currentGuard) {
        return f.guards.pop();
      }
    }), Op('SR1', function(f, s, l) {
      return f.fiber.r1 = s.pop();
    }), Op('SR2', function(f, s, l) {
      return f.fiber.r2 = s.pop();
    }), Op('SR3', function(f, s, l) {
      return f.fiber.r3 = s.pop();
    }), Op('LR1', function(f, s, l) {
      return s.push(f.fiber.r1);
    }), Op('LR2', function(f, s, l) {
      return s.push(f.fiber.r2);
    }), Op('LR3', function(f, s, l) {
      return s.push(f.fiber.r3);
    }), Op('SREXP', function(f, s, l) {
      return s.fiber.rexp = s.pop();
    }), Op('ITER', function(f, s, l) {
      return callm(f, 0, 'iterator', s.pop());
    }), Op('ENUMERATE', function(f, s, l, r) {
      return s.push(r.enumerateKeys(s.pop()));
    }), Op('NEXT', function(f, s, l) {
      callm(f, 0, 'next', s.pop());
      if (f.error instanceof StopIteration) {
        f.error = null;
        f.paused = false;
        return f.ip = this.args[0];
      }
    }), Op('FUNCTION_SETUP', function(f, s, l) {
      var fn;
      l.set(1, s.pop());
      fn = s.pop();
      if (this.args[0]) {
        return l.set(2, fn);
      }
    }, function() {
      return 0;
    }), Op('GLOBAL', function(f, s, l, r) {
      return s.push(r.global);
    }), Op('REST', function(f, s, l, r) {
      var args, index, varIndex;
      index = this.args[0];
      varIndex = this.args[1];
      args = l.get(1);
      if (index < args.length) {
        return l.set(varIndex, Array.prototype.slice.call(args, index));
      }
    }), Op('NEW', function(f, s, l) {
      return call(f, this.args[0], s.pop(), null, null, true);
    }), Op('CALL', function(f, s, l) {
      return call(f, this.args[0], s.pop(), null, this.args[1]);
    }, function() {
      return 1 - (this.args[0] + 1);
    }), Op('CALLM', function(f, s, l) {
      return callm(f, this.args[0], s.pop(), s.pop(), this.args[1]);
    }, function() {
      return 1 - (this.args[0] + 1 + 1);
    }), Op('GET', function(f, s, l, r) {
      var key, obj;
      obj = s.pop();
      key = s.pop();
      if (obj == null) {
        return throwErr(f, new VmTypeError("Cannot read property '" + key + "' of " + obj));
      }
      return s.push(r.get(obj, key));
    }), Op('SET', function(f, s, l, r) {
      var key, obj, val;
      obj = s.pop();
      key = s.pop();
      val = s.pop();
      if (obj == null) {
        return throwErr(f, new VmTypeError("Cannot set property '" + key + "' of " + obj));
      }
      return s.push(r.set(obj, key, val));
    }), Op('DEL', function(f, s, l, r) {
      var key, obj;
      obj = s.pop();
      key = s.pop();
      if (obj == null) {
        return throwErr(f, new VmTypeError('Cannot convert null to object'));
      }
      return s.push(r.del(obj, key));
    }), Op('GETL', function(f, s, l) {
      var scope, scopeIndex, varIndex;
      scopeIndex = this.args[0];
      varIndex = this.args[1];
      scope = l;
      while (scopeIndex--) {
        scope = scope.parent;
      }
      return s.push(scope.get(varIndex));
    }), Op('SETL', function(f, s, l) {
      var scope, scopeIndex, varIndex;
      scopeIndex = this.args[0];
      varIndex = this.args[1];
      scope = l;
      while (scopeIndex--) {
        scope = scope.parent;
      }
      return s.push(scope.set(varIndex, s.pop()));
    }), Op('GETW', function(f, s, l, r) {
      var idx, key;
      key = this.args[0];
      while (l instanceof WithScope) {
        if (l.has(key)) {
          return s.push(l.get(key));
        }
        l = l.parent;
      }
      while (l instanceof Scope) {
        idx = l.name(key);
        if (idx >= 0) {
          return s.push(l.get(idx));
        }
        l = l.parent;
      }
      if (!hasProp(r.global, key) && !this.args[1]) {
        return throwErr(f, new VmReferenceError("" + key + " is not defined"));
      }
      return s.push(r.global[key]);
    }), Op('SETW', function(f, s, l, r) {
      var idx, key, value;
      key = this.args[0];
      value = s.pop();
      while (l instanceof WithScope) {
        if (l.has(key)) {
          return s.push(l.set(key, value));
        }
        l = l.parent;
      }
      while (l instanceof Scope) {
        idx = l.name(key);
        if (idx >= 0) {
          return s.push(l.set(idx, value));
        }
        l = l.parent;
      }
      return s.push(r.global[key] = value);
    }), Op('GETG', function(f, s, l, r) {
      if (!hasProp(r.global, this.args[0]) && !this.args[1]) {
        return throwErr(f, new VmReferenceError("" + this.args[0] + " is not defined"));
      }
      return s.push(r.global[this.args[0]]);
    }), Op('SETG', function(f, s, l, r) {
      return s.push(r.global[this.args[0]] = s.pop());
    }), Op('ENTER_SCOPE', function(f) {
      return f.scope = new Scope(f.scope, f.script.localNames, f.script.localLength);
    }), Op('EXIT_SCOPE', function(f) {
      return f.scope = f.scope.parent;
    }), Op('ENTER_WITH', function(f, s) {
      return f.scope = new WithScope(f.scope, s.pop());
    }), Op('INV', function(f, s, l, r) {
      return s.push(r.inv(s.pop()));
    }), Op('LNOT', function(f, s, l, r) {
      return s.push(r.lnot(s.pop()));
    }), Op('NOT', function(f, s, l, r) {
      return s.push(r.not(s.pop()));
    }), Op('INC', function(f, s, l, r) {
      return s.push(r.inc(s.pop()));
    }), Op('DEC', function(f, s, l, r) {
      return s.push(r.dec(s.pop()));
    }), Op('ADD', function(f, s, l, r) {
      return s.push(r.add(s.pop(), s.pop()));
    }), Op('SUB', function(f, s, l, r) {
      return s.push(r.sub(s.pop(), s.pop()));
    }), Op('MUL', function(f, s, l, r) {
      return s.push(r.mul(s.pop(), s.pop()));
    }), Op('DIV', function(f, s, l, r) {
      return s.push(r.div(s.pop(), s.pop()));
    }), Op('MOD', function(f, s, l, r) {
      return s.push(r.mod(s.pop(), s.pop()));
    }), Op('SHL', function(f, s, l, r) {
      return s.push(r.shl(s.pop(), s.pop()));
    }), Op('SAR', function(f, s, l, r) {
      return s.push(r.sar(s.pop(), s.pop()));
    }), Op('SHR', function(f, s, l, r) {
      return s.push(r.shr(s.pop(), s.pop()));
    }), Op('OR', function(f, s, l, r) {
      return s.push(r.or(s.pop(), s.pop()));
    }), Op('AND', function(f, s, l, r) {
      return s.push(r.and(s.pop(), s.pop()));
    }), Op('XOR', function(f, s, l, r) {
      return s.push(r.xor(s.pop(), s.pop()));
    }), Op('CEQ', function(f, s, l, r) {
      return s.push(r.ceq(s.pop(), s.pop()));
    }), Op('CNEQ', function(f, s, l, r) {
      return s.push(r.cneq(s.pop(), s.pop()));
    }), Op('CID', function(f, s, l, r) {
      return s.push(r.cid(s.pop(), s.pop()));
    }), Op('CNID', function(f, s, l, r) {
      return s.push(r.cnid(s.pop(), s.pop()));
    }), Op('LT', function(f, s, l, r) {
      return s.push(r.lt(s.pop(), s.pop()));
    }), Op('LTE', function(f, s, l, r) {
      return s.push(r.lte(s.pop(), s.pop()));
    }), Op('GT', function(f, s, l, r) {
      return s.push(r.gt(s.pop(), s.pop()));
    }), Op('GTE', function(f, s, l, r) {
      return s.push(r.gte(s.pop(), s.pop()));
    }), Op('IN', function(f, s, l, r) {
      return s.push(r.has(s.pop(), s.pop()));
    }), Op('INSTANCEOF', function(f, s, l, r) {
      return s.push(r.instanceOf(s.pop(), s.pop()));
    }), Op('TYPEOF', function(f, s, l, r) {
      return s.push(typeof s.pop());
    }), Op('VOID', function(f, s) {
      s.pop();
      return s.push(void 0);
    }), Op('JMP', function(f, s, l) {
      return f.ip = this.args[0];
    }), Op('JMPT', function(f, s, l) {
      if (s.pop()) {
        return f.ip = this.args[0];
      }
    }), Op('JMPF', function(f, s, l) {
      if (!s.pop()) {
        return f.ip = this.args[0];
      }
    }), Op('UNDEF', function(f, s) {
      return s.push(void 0);
    }), Op('LITERAL', function(f, s, l) {
      return s.push(this.args[0]);
    }), Op('STRING_LITERAL', function(f, s, l) {
      return s.push(f.script.strings[this.args[0]]);
    }), Op('REGEXP_LITERAL', function(f, s, l, r) {
      return s.push(new RegExpProxy(f.script.regexps[this.args[0]], r));
    }), Op('OBJECT_LITERAL', function(f, s, l, r) {
      var length, rv;
      length = this.args[0];
      rv = {};
      while (length--) {
        r.set(rv, s.pop(), s.pop());
      }
      return s.push(rv);
    }, function() {
      return 1 - (this.args[0] * 2);
    }), Op('ARRAY_LITERAL', function(f, s, l, r) {
      var length, rv;
      length = this.args[0];
      rv = new Array(length);
      while (length--) {
        rv[length] = s.pop();
      }
      return s.push(rv);
    }, function() {
      return 1 - this.args[0];
    }), Op('FUNCTION', function(f, s, l, r) {
      var scriptIndex;
      scriptIndex = this.args[0];
      return s.push(createFunction(f.script.scripts[scriptIndex], l, r, this.args[1]));
    }), Op('LINE', function(f) {
      return f.setLine(this.args[0]);
    }), Op('COLUMN', function(f) {
      return f.setColumn(this.args[0]);
    }), Op('DEBUG', function(f, s, l) {
      return debug();
    })
  ];

  throwErr = function(frame, err) {
    frame.error = err;
    return frame.paused = true;
  };

  callm = function(frame, length, key, target, name) {
    var constructor, func, id, realm, stack, targetName;
    stack = frame.evalStack, realm = frame.realm;
    if (target == null) {
      id = 'null';
      if (target === void 0) {
        id = 'undefined';
      }
      return throwErr(frame, new VmTypeError("Cannot call method '" + key + "' of " + id));
    }
    constructor = target.constructor;
    targetName = constructor.__name__ || constructor.name || 'Object';
    name = "" + targetName + "." + name;
    func = realm.get(target, key);
    if (func instanceof Function) {
      return call(frame, length, func, target, name);
    }
    if (func == null) {
      stack.pop();
      return throwErr(frame, new VmTypeError("Object #<" + targetName + "> has no method '" + key + "'"));
    } else {
      stack.pop();
      return throwErr(frame, new VmTypeError("Property '" + key + "' of object #<" + targetName + "> is not a function"));
    }
  };

  call = function(frame, length, func, target, name, construct) {
    var args, e, fiber, nativeError, push, realm, script, stack, val;
    if (typeof func !== 'function') {
      return throwErr(frame, new VmTypeError("object is not a function"));
    }
    stack = frame.evalStack, fiber = frame.fiber, realm = frame.realm;
    args = {
      length: length,
      callee: func
    };
    while (length) {
      args[--length] = stack.pop();
    }
    target = target || realm.global;
    push = true;
    args = Array.prototype.slice.call(args);
    if (func === Function || func === realm["eval"]) {
      try {
        if (func === Function) {
          stack.push(createFunction(realm.compileFunction(args), null, realm));
        } else {
          script = realm["eval"](frame, args[0]);
          frame.paused = true;
          fiber.pushEvalFrame(frame, script);
        }
      } catch (_error) {
        e = _error;
        throwErr(frame, new VmEvalError(e.message));
      }
      return;
    }
    if (hasProp(func, '__vmfunction__')) {
      func.__callname__ = name;
      func.__fiber__ = fiber;
      func.__construct__ = construct;
      push = false;
    }
    try {
      if (construct) {
        val = createNativeInstance(func, args);
      } else {
        val = func.apply(target, args);
      }
      if (push && !fiber.paused) {
        return stack.push(val);
      }
    } catch (_error) {
      nativeError = _error;
      return throwErr(frame, nativeError);
    }
  };

  createGenerator = function(caller, script, scope, realm, target, args, fn, callname) {
    var close, fiber, frame, newborn, rv, send, thrw, timeout;
    if (caller) {
      timeout = caller.timeout;
    }
    fiber = new Fiber(realm, timeout);
    frame = fiber.pushFrame(script, target, scope, args, fn, callname, false);
    newborn = true;
    send = function(obj) {
      if (newborn && obj !== void 0) {
        throw new VmTypeError('no argument must be passed when starting generator');
      }
      if (fiber.done()) {
        throw new VmError('generator closed');
      }
      frame = fiber.callStack[fiber.depth];
      if (newborn) {
        newborn = false;
        fiber.run();
      } else {
        frame.evalStack.push(obj);
        fiber.resume();
      }
      if (caller) {
        caller.timeout = fiber.timeout;
      }
      if (fiber.done()) {
        rv.closed = true;
        throw new StopIteration(fiber.rv, 'generator has stopped');
      }
      return fiber.yielded;
    };
    thrw = function(e) {
      if (newborn) {
        close();
        return e;
      }
      if (fiber.done()) {
        throw new VmError('generator closed');
      }
      frame = fiber.callStack[fiber.depth];
      frame.error = e;
      fiber.resume();
      if (caller) {
        caller.timeout = fiber.timeout;
      }
      if (fiber.done()) {
        return fiber.rv;
      }
      return fiber.yielded;
    };
    close = function() {
      if (fiber.done()) {
        return;
      }
      if (newborn) {
        fiber.depth = -1;
      }
      frame = fiber.callStack[fiber.depth];
      frame.evalStack.clear();
      frame.ip = frame.exitIp;
      fiber.resume();
      if (caller) {
        caller.timeout = fiber.timeout;
      }
      return fiber.rv;
    };
    rv = {
      next: send,
      send: send,
      "throw": thrw,
      close: close,
      closed: false,
      iterator: function() {
        return rv;
      }
    };
    return rv;
  };

  createFunction = function(script, scope, realm, generator) {
    var rv;
    if (generator) {
      rv = function() {
        var fiber, gen, name;
        name = rv.__callname__ || script.name;
        gen = createGenerator(rv.__fiber__, script, scope, realm, this, arguments, rv, name);
        if (!(fiber = rv.__fiber__)) {
          return gen;
        }
        fiber.callStack[fiber.depth].evalStack.push(gen);
        rv.__fiber__ = null;
        return rv.__callname__ = null;
      };
    } else {
      rv = function() {
        var construct, fiber, name, run;
        run = false;
        if (fiber = rv.__fiber__) {
          fiber.callStack[fiber.depth].paused = true;
          rv.__fiber__ = null;
          construct = rv.__construct__;
          rv.__construct__ = null;
        } else {
          fiber = new Fiber(realm);
          run = true;
        }
        name = rv.__callname__ || script.name;
        rv.__callname__ = null;
        fiber.pushFrame(script, this, scope, arguments, rv, name, construct);
        if (run) {
          fiber.run();
          return fiber.rv;
        }
      };
    }
    defProp(rv, '__vmfunction__', {
      value: true
    });
    defProp(rv, '__source__', {
      value: script.source
    });
    defProp(rv, '__name__', {
      value: script.name
    });
    defProp(rv, '__construct__', {
      value: null,
      writable: true
    });
    defProp(rv, '__fiber__', {
      value: null,
      writable: true
    });
    defProp(rv, '__callname__', {
      value: null,
      writable: true
    });
    return rv;
  };

  ret = function(frame) {
    frame.evalStack.clear();
    return frame.exitIp = frame.ip;
  };

  debug = function() {};

  callDateConstructor = function(a) {
    var rv;
    switch (a.length) {
      case 0:
        rv = new Date();
        break;
      case 1:
        rv = new Date(a[0]);
        break;
      case 2:
        rv = new Date(a[0], a[1]);
        break;
      case 3:
        rv = new Date(a[0], a[1], a[2]);
        break;
      case 4:
        rv = new Date(a[0], a[1], a[2], a[3]);
        break;
      case 5:
        rv = new Date(a[0], a[1], a[2], a[3], a[4]);
        break;
      case 6:
        rv = new Date(a[0], a[1], a[2], a[3], a[4], a[5]);
        break;
      default:
        rv = new Date(a[0], a[1], a[2], a[3], a[4], a[5], a[6]);
    }
    return rv;
  };

  callArrayConstructor = function(a) {
    if (a.length === 1 && (a[0] | 0) === a[0]) {
      return new Array(a[0]);
    }
    return a.slice();
  };

  callRegExpConstructor = function(a) {
    if (a.length === 1) {
      return new RegExp(a[0]);
    } else {
      return new RegExp(a[0], a[1]);
    }
  };

  createNativeInstance = function(constructor, args) {
    var constructorProxy, rv;
    if (constructor === Date) {
      return callDateConstructor(args);
    } else if (constructor === Array) {
      return callArrayConstructor(args);
    } else if (constructor === RegExp) {
      return callRegExpConstructor(args);
    } else if (constructor === Number) {
      return new Number(args[0]);
    } else if (constructor === Boolean) {
      return new Boolean(args[0]);
    } else {
      constructorProxy = function() {
        return constructor.apply(this, args);
      };
      constructorProxy.prototype = constructor.prototype;
      rv = new constructorProxy();
      return rv;
    }
  };

  module.exports = opcodes;

}).call(this);


//@ sourceMappingURL=opcodes.js.map