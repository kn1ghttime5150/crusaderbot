(function() {
  var EvalFrame, EvaluationStack, Fiber, Frame, Scope, VmError, VmTimeoutError, WithScope, isArray, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('../runtime/errors'), VmError = _ref.VmError, VmTimeoutError = _ref.VmTimeoutError;

  isArray = require('../runtime/util').isArray;

  Fiber = (function() {
    function Fiber(realm, timeout) {
      this.realm = realm;
      this.timeout = timeout != null ? timeout : -1;
      this.maxDepth = 1000;
      this.maxTraceDepth = 50;
      this.callStack = [];
      this.evalStack = null;
      this.depth = -1;
      this.yielded = this.rv = void 0;
      this.paused = false;
      this.r1 = this.r2 = this.r3 = null;
      this.rexp = null;
    }

    Fiber.prototype.run = function() {
      var err, frame, guard, _ref1;
      frame = this.callStack[this.depth];
      err = frame.error;
      while (this.depth >= 0 && frame && !this.paused) {
        if (err) {
          frame = this.unwind(err);
        }
        frame.run();
        if ((err = frame.error) instanceof VmError) {
          this.injectStackTrace(err);
        }
        if (frame.done()) {
          if (frame.guards.length) {
            guard = frame.guards.pop();
            if (guard.finalizer) {
              frame.ip = guard.finalizer;
              frame.exitIp = guard.end;
              frame.paused = false;
              continue;
            }
          }
        } else {
          frame = this.callStack[this.depth];
          err = frame.error;
          continue;
        }
        if (frame.construct) {
          if ((_ref1 = typeof this.rv) !== 'object' && _ref1 !== 'function') {
            this.rv = frame.scope.get(0);
          }
        }
        frame = this.popFrame();
        if (frame && !err) {
          frame.evalStack.push(this.rv);
          this.rv = void 0;
        }
      }
      if (this.timedOut()) {
        err = new VmTimeoutError(this);
        this.injectStackTrace(err);
      }
      if (err) {
        throw err;
      }
    };

    Fiber.prototype.unwind = function(err) {
      var frame, guard, ip, len;
      frame = this.callStack[this.depth];
      while (frame) {
        frame.error = err;
        ip = frame.ip - 1;
        if (len = frame.guards.length) {
          guard = frame.guards[len - 1];
          if ((guard.start <= ip && ip <= guard.end)) {
            if (guard.handler !== null) {
              if (ip <= guard.handler) {
                frame.evalStack.push(err);
                frame.error = null;
                frame.ip = guard.handler;
              } else {
                if (guard.finalizer && frame.ip <= guard.finalizer) {
                  frame.ip = guard.finalizer;
                } else {
                  frame = this.popFrame();
                  continue;
                }
              }
            } else {
              frame.ip = guard.finalizer;
            }
            frame.paused = false;
            return frame;
          }
        }
        frame = this.popFrame();
      }
      throw err;
    };

    Fiber.prototype.injectStackTrace = function(err) {
      var frame, i, minDepth, name, t, trace, _i, _ref1;
      trace = [];
      minDepth = 0;
      if (this.depth > this.maxTraceDepth) {
        minDepth = this.depth - this.maxTraceDepth;
      }
      for (i = _i = _ref1 = this.depth; _ref1 <= minDepth ? _i <= minDepth : _i >= minDepth; i = _ref1 <= minDepth ? ++_i : --_i) {
        frame = this.callStack[i];
        name = frame.script.name;
        if (name === '<anonymous>' && frame.fname) {
          name = frame.fname;
        }
        trace.push({
          at: {
            name: name,
            filename: frame.script.filename
          },
          line: frame.line,
          column: frame.column
        });
      }
      if (err.trace) {
        t = err.trace;
        while (isArray(t[t.length - 1])) {
          t = t[t.length - 1];
        }
        t.push(trace);
      } else {
        err.trace = trace;
      }
      return err.stack = err.toString();
    };

    Fiber.prototype.pushFrame = function(script, target, parent, args, self, name, construct) {
      var frame, scope;
      if (name == null) {
        name = '<anonymous>';
      }
      if (construct == null) {
        construct = false;
      }
      if (!this.checkCallStack()) {
        return;
      }
      scope = new Scope(parent, script.localNames, script.localLength);
      scope.set(0, target);
      frame = new Frame(this, script, scope, this.realm, name, construct);
      if (self) {
        frame.evalStack.push(self);
      }
      if (args) {
        frame.evalStack.push(args);
      }
      this.callStack[++this.depth] = frame;
      return frame;
    };

    Fiber.prototype.pushEvalFrame = function(frame, script) {
      if (!this.checkCallStack()) {
        return;
      }
      return this.callStack[++this.depth] = new EvalFrame(frame, script);
    };

    Fiber.prototype.checkCallStack = function() {
      if (this.depth === this.maxDepth) {
        this.callStack[this.depth].error = new VmError('maximum call stack size exceeded');
        this.pause();
        return false;
      }
      return true;
    };

    Fiber.prototype.popFrame = function() {
      var frame;
      frame = this.callStack[--this.depth];
      if (frame) {
        frame.paused = false;
      }
      return frame;
    };

    Fiber.prototype.setReturnValue = function(rv) {
      return this.callStack[this.depth].evalStack.push(rv);
    };

    Fiber.prototype.pause = function() {
      return this.paused = this.callStack[this.depth].paused = true;
    };

    Fiber.prototype.resume = function(timeout) {
      var evalStack, frame;
      this.timeout = timeout != null ? timeout : -1;
      this.paused = false;
      frame = this.callStack[this.depth];
      frame.paused = false;
      evalStack = this.callStack[0].evalStack;
      this.run();
      if (!this.paused) {
        return this.rexp;
      }
    };

    Fiber.prototype.timedOut = function() {
      return this.timeout === 0;
    };

    Fiber.prototype.send = function(obj) {
      return this.callStack[this.depth].evalStack.push(obj);
    };

    Fiber.prototype.done = function() {
      return this.depth === -1;
    };

    return Fiber;

  })();

  Frame = (function() {
    function Frame(fiber, script, scope, realm, fname, construct) {
      this.fiber = fiber;
      this.script = script;
      this.scope = scope;
      this.realm = realm;
      this.fname = fname;
      this.construct = construct != null ? construct : false;
      this.evalStack = new EvaluationStack(this.script.stackSize, this.fiber);
      this.ip = 0;
      this.exitIp = this.script.instructions.length;
      this.paused = false;
      this.finalizer = null;
      this.guards = [];
      this.rv = void 0;
      this.line = this.column = -1;
    }

    Frame.prototype.run = function() {
      var instructions, len;
      instructions = this.script.instructions;
      while (this.ip !== this.exitIp && !this.paused && this.fiber.timeout !== 0) {
        this.fiber.timeout--;
        instructions[this.ip++].exec(this, this.evalStack, this.scope, this.realm);
      }
      if (this.fiber.timeout === 0) {
        this.paused = this.fiber.paused = true;
      }
      if (!this.paused && !this.error && (len = this.evalStack.len()) !== 0) {
        throw new Error("Evaluation stack has " + len + " items after execution");
      }
    };

    Frame.prototype.done = function() {
      return this.ip === this.exitIp;
    };

    Frame.prototype.setLine = function(line) {
      this.line = line;
    };

    Frame.prototype.setColumn = function(column) {
      this.column = column;
    };

    return Frame;

  })();

  EvalFrame = (function(_super) {
    __extends(EvalFrame, _super);

    function EvalFrame(frame, script) {
      var guard, _i, _len, _ref1;
      _ref1 = frame.script.guards;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        guard = _ref1[_i];
        script.guards.push(guard);
      }
      EvalFrame.__super__.constructor.call(this, frame.fiber, script, frame.scope, frame.realm, script.filename);
    }

    EvalFrame.prototype.run = function() {
      EvalFrame.__super__.run.call(this);
      return this.fiber.rv = this.fiber.rexp;
    };

    return EvalFrame;

  })(Frame);

  EvaluationStack = (function() {
    function EvaluationStack(size, fiber) {
      this.fiber = fiber;
      this.array = new Array(size);
      this.idx = 0;
    }

    EvaluationStack.prototype.push = function(item) {
      if (this.idx === this.array.length) {
        throw new Error('maximum evaluation stack size exceeded');
      }
      return this.array[this.idx++] = item;
    };

    EvaluationStack.prototype.pop = function() {
      return this.array[--this.idx];
    };

    EvaluationStack.prototype.top = function() {
      return this.array[this.idx - 1];
    };

    EvaluationStack.prototype.len = function() {
      return this.idx;
    };

    EvaluationStack.prototype.clear = function() {
      return this.idx = 0;
    };

    return EvaluationStack;

  })();

  Scope = (function() {
    function Scope(parent, names, len) {
      this.parent = parent;
      this.names = names;
      this.data = new Array(len);
    }

    Scope.prototype.get = function(i) {
      return this.data[i];
    };

    Scope.prototype.set = function(i, value) {
      return this.data[i] = value;
    };

    Scope.prototype.name = function(name) {
      var k, v, _ref1;
      _ref1 = this.names;
      for (k in _ref1) {
        if (!__hasProp.call(_ref1, k)) continue;
        v = _ref1[k];
        if (v === name) {
          return parseInt(k);
        }
      }
      return -1;
    };

    Scope.prototype.namesHash = function() {
      var k, rv, v, _ref1;
      rv = {};
      _ref1 = this.names;
      for (k in _ref1) {
        if (!__hasProp.call(_ref1, k)) continue;
        v = _ref1[k];
        if (typeof v === 'string') {
          rv[v] = parseInt(k);
        }
      }
      rv['this'] = 0;
      rv['arguments'] = 1;
      return rv;
    };

    return Scope;

  })();

  WithScope = (function() {
    function WithScope(parent, object) {
      this.parent = parent;
      this.object = object;
    }

    WithScope.prototype.get = function(name) {
      return this.object[name];
    };

    WithScope.prototype.set = function(name, value) {
      return this.object[name] = value;
    };

    WithScope.prototype.has = function(name) {
      return name in this.object;
    };

    return WithScope;

  })();

  exports.Fiber = Fiber;

  exports.Scope = Scope;

  exports.WithScope = WithScope;

}).call(this);


//@ sourceMappingURL=thread.js.map