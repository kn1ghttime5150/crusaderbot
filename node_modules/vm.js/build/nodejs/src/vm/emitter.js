(function() {
  var Emitter, FUNCTION, GETG, GETL, Label, POP, SETG, SETL, Script, Visitor, assignOp, binaryOp, hasProp, opcodes, parse, unaryOp,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  parse = require('esprima').parse;

  Script = require('./script');

  opcodes = require('./opcodes');

  Visitor = require('../ast/visitor');

  hasProp = require('../runtime/util').hasProp;

  Emitter = (function(_super) {
    __extends(Emitter, _super);

    function Emitter(scopes, filename, name, original, source) {
      this.filename = filename;
      this.name = name;
      this.original = original;
      this.source = source;
      this.instructions = [];
      this.labels = [];
      this.scripts = [];
      this.tryStatements = [];
      this.withLevel = 0;
      this.scopes = scopes || [];
      if (scopes) {
        this.scriptScope = scopes[0];
      }
      this.localNames = [];
      this.varIndex = 3;
      this.guards = [];
      this.currentLine = -1;
      this.currentColumn = -1;
      this.stringIds = {};
      this.strings = [];
      this.regexpIds = {};
      this.regexps = [];
      this.ignoreNotDefined = 0;
    }

    Emitter.prototype.scope = function(name) {
      var crossFunctionScope, i, scope, _i, _len, _ref;
      i = 0;
      crossFunctionScope = false;
      _ref = this.scopes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        scope = _ref[_i];
        if (hasProp(scope, name)) {
          return [i, scope[name]];
        }
        if (crossFunctionScope || scope === this.scriptScope) {
          crossFunctionScope = true;
          i++;
        }
      }
      return null;
    };

    Emitter.prototype.scopeGet = function(name) {
      var scope;
      if (this.withLevel) {
        this.GETW(name, this.ignoreNotDefined);
        this.ignoreNotDefined = 0;
        return;
      }
      scope = this.scope(name);
      if (scope) {
        this.ignoreNotDefined = 0;
        this.GETL.apply(this, scope);
        return;
      }
      this.GETG(name, this.ignoreNotDefined);
      this.ignoreNotDefined = 0;
    };

    Emitter.prototype.scopeSet = function(name) {
      var scope;
      if (this.withLevel) {
        return this.SETW(name);
      }
      scope = this.scope(name);
      if (scope) {
        return this.SETL.apply(this, scope);
      }
      return this.SETG(name);
    };

    Emitter.prototype.enterScope = function() {
      if (!this.scopes.length) {
        this.ENTER_SCOPE();
      }
      return this.scopes.unshift({});
    };

    Emitter.prototype.exitScope = function() {
      this.scopes.shift();
      if (!this.scopes.length) {
        return this.EXIT_SCOPE();
      }
    };

    Emitter.prototype.addCleanupHook = function(cleanup) {
      var label, tryStatement, _i, _j, _len, _len1, _ref, _ref1, _results;
      _ref = this.labels;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        label = _ref[_i];
        if (label.name) {
          if (!label.cleanup) {
            label.cleanup = [];
          }
          label.cleanup.push(cleanup);
        }
      }
      _ref1 = this.tryStatements;
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        tryStatement = _ref1[_j];
        _results.push(tryStatement.hooks.push(cleanup));
      }
      return _results;
    };

    Emitter.prototype.declareVar = function(name, kind) {
      var scope;
      if (kind === 'const' || kind === 'var') {
        scope = this.scriptScope;
      } else {
        scope = this.scopes[0];
      }
      if (scope && !scope[name]) {
        this.localNames[this.varIndex] = name;
        return scope[name] = this.varIndex++;
      }
    };

    Emitter.prototype.declarePattern = function(node, kind) {
      var el, prop, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _results, _results1;
      if ((_ref = node.type) === 'ArrayPattern' || _ref === 'ArrayExpression') {
        _ref1 = node.elements;
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          el = _ref1[_i];
          if (el) {
            _results.push(this.declarePattern(el, kind));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      } else if ((_ref2 = node.type) === 'ObjectPattern' || _ref2 === 'ObjectExpression') {
        _ref3 = node.properties;
        _results1 = [];
        for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
          prop = _ref3[_j];
          _results1.push(this.declarePattern(prop.value, kind));
        }
        return _results1;
      } else if (node.type === 'Identifier') {
        return this.declareVar(node.name, kind);
      } else {
        throw new Error('assertion error');
      }
    };

    Emitter.prototype.newLabel = function() {
      return new Label(this);
    };

    Emitter.prototype.label = function(name) {
      var label, _i, _len, _ref;
      if (!name) {
        return this.labels[this.labels.length - 1];
      }
      _ref = this.labels;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        label = _ref[_i];
        if (label.name === name) {
          return label;
        }
      }
      return null;
    };

    Emitter.prototype.pushLabel = function(name, stmt, brk, cont) {
      return this.labels.push({
        name: name,
        stmt: stmt,
        brk: brk,
        cont: cont
      });
    };

    Emitter.prototype.popLabel = function() {
      return this.labels.pop();
    };

    Emitter.prototype.declareFunction = function(name, index, generator) {
      var code, codes, i, opcode, processedLabels, s, scope, _i, _ref, _results;
      this.declareVar(name);
      scope = this.scope(name);
      if (scope) {
        opcode = new SETL(scope);
      } else {
        opcode = new SETG([name]);
      }
      codes = [new FUNCTION([index, generator]), opcode, new POP()];
      this.instructions = codes.concat(this.instructions);
      processedLabels = {};
      _results = [];
      for (i = _i = 0, _ref = this.instructions.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        code = this.instructions[i];
        if (this.scopes.length && code instanceof GETG) {
          if (code.args[0] === name) {
            this.instructions[i] = new GETL(scope);
          }
        }
        if (code instanceof GETL) {
          if (code.args[0] !== 0) {
            s = this.scopes[code.args[0]];
            if (s[name] === code.args[1]) {
              this.instructions[i] = new GETL(scope);
            }
          }
        }
        _results.push(code.forEachLabel(function(l) {
          if (hasProp(processedLabels, l.id)) {
            return l;
          }
          processedLabels[l.id] = null;
          if (l.ip != null) {
            l.ip += 3;
          }
          return l;
        }));
      }
      return _results;
    };

    Emitter.prototype.end = function() {
      var code, current, guard, i, k, localLength, max, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref, _ref1, _ref2, _ref3, _ref4;
      _ref = this.instructions;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        code = _ref[_i];
        code.forEachLabel(function(l) {
          if (l.ip === null) {
            throw new Error('label has not been marked');
          }
          return l.ip;
        });
      }
      _ref1 = this.guards;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        guard = _ref1[_j];
        guard.start = guard.start.ip;
        if (guard.handler) {
          guard.handler = guard.handler.ip;
        }
        if (guard.finalizer) {
          guard.finalizer = guard.finalizer.ip;
        }
        guard.end = guard.end.ip;
      }
      current = max = 2;
      _ref2 = this.instructions;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        code = _ref2[_k];
        current += code.calculateFactor();
        max = Math.max(current, max);
      }
      localLength = 0;
      _ref3 = this.localNames;
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        k = _ref3[_l];
        localLength++;
      }
      for (i = _m = 0, _ref4 = this.scripts.length; 0 <= _ref4 ? _m < _ref4 : _m > _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
        this.scripts[i] = this.scripts[i]();
      }
      return new Script(this.filename, this.name, this.instructions, this.scripts, this.localNames, localLength, this.guards, max, this.strings, this.regexps, this.source);
    };

    Emitter.prototype.visit = function(node) {
      var column, idx, line, _ref;
      if (node == null) {
        return;
      }
      if (node.loc) {
        _ref = node.loc.start, line = _ref.line, column = _ref.column;
        if (line !== this.currentLine) {
          idx = this.instructions.length - 1;
          while (this.instructions[idx] instanceof opcodes.LINE || this.instructions[idx] instanceof opcodes.COLUMN) {
            this.instructions.pop();
            idx--;
          }
          this.LINE(line);
          this.currentLine = line;
        } else if (column !== this.currentColumn) {
          idx = this.instructions.length - 1;
          while (this.instructions[idx] instanceof opcodes.COLUMN) {
            this.instructions.pop();
            idx--;
          }
          this.COLUMN(column);
          this.currentColumn = column;
        }
      }
      return Emitter.__super__.visit.call(this, node);
    };

    Emitter.prototype.BlockStatement = function(node) {
      this.enterScope();
      if (node.blockInit) {
        node.blockInit();
      }
      this.visit(node.body);
      if (node.blockCleanup) {
        node.blockCleanup();
      }
      this.exitScope();
      return node;
    };

    Emitter.prototype.VmLoop = function(node, emitInit, emitBeforeTest, emitUpdate, emitAfterTest) {
      var blockCleanup, blockInit, brk, cont, currentLabel, start,
        _this = this;
      blockInit = function() {
        if (emitInit) {
          emitInit(brk);
        }
        if (emitUpdate) {
          start.mark();
        } else {
          cont.mark();
        }
        if (emitBeforeTest) {
          emitBeforeTest();
          return _this.JMPF(brk);
        }
      };
      blockCleanup = function() {
        if (emitUpdate) {
          cont.mark();
          emitUpdate(brk);
          _this.POP();
          _this.JMP(start);
        }
        if (emitAfterTest) {
          emitAfterTest();
          _this.JMPF(brk);
        }
        return _this.JMP(cont);
      };
      currentLabel = this.label();
      start = this.newLabel();
      cont = this.newLabel();
      brk = this.newLabel();
      if ((currentLabel != null ? currentLabel.stmt : void 0) === node) {
        currentLabel.cont = cont;
      }
      this.pushLabel(null, node, brk, cont);
      if (node.body.type === 'BlockStatement') {
        node.body.blockInit = blockInit;
        node.body.blockCleanup = blockCleanup;
        this.visit(node.body);
      } else {
        this.enterScope();
        blockInit();
        this.visit(node.body);
        blockCleanup();
        this.exitScope();
      }
      brk.mark();
      this.popLabel();
      return node;
    };

    Emitter.prototype.VmIteratorLoop = function(node, pushIterator) {
      var assignNext, assignTarget, emitInit, emitUpdate, labelCleanup,
        _this = this;
      labelCleanup = function(label, isBreak) {
        if (!label || label.stmt !== node || isBreak) {
          return _this.POP();
        }
      };
      emitInit = function(brk) {
        if (node.left.type === 'VariableDeclaration') {
          _this.visit(node.left);
        }
        _this.visit(node.right);
        pushIterator();
        emitUpdate(brk);
        return _this.POP();
      };
      emitUpdate = function(brk) {
        _this.DUP();
        _this.NEXT(brk);
        return _this.visit(assignNext());
      };
      assignNext = function() {
        return {
          loc: node.left.loc,
          type: 'AssignmentExpression',
          operator: '=',
          left: assignTarget
        };
      };
      this.addCleanupHook(labelCleanup);
      assignTarget = node.left;
      if (assignTarget.type === 'VariableDeclaration') {
        assignTarget = node.left.declarations[0].id;
      }
      this.VmLoop(node, emitInit, null, emitUpdate);
      this.POP();
      return node;
    };

    Emitter.prototype.WhileStatement = function(node) {
      var emitBeforeTest,
        _this = this;
      emitBeforeTest = function() {
        return _this.visit(node.test);
      };
      this.VmLoop(node, null, emitBeforeTest);
      return node;
    };

    Emitter.prototype.DoWhileStatement = function(node) {
      var emitAfterTest,
        _this = this;
      emitAfterTest = function() {
        return _this.visit(node.test);
      };
      this.VmLoop(node, null, null, null, emitAfterTest);
      return node;
    };

    Emitter.prototype.ForStatement = function(node) {
      var emitBeforeTest, emitInit, emitUpdate,
        _this = this;
      emitInit = function() {
        _this.visit(node.init);
        if (node.init.type !== 'VariableDeclaration') {
          return _this.POP();
        }
      };
      emitBeforeTest = function() {
        return _this.visit(node.test);
      };
      emitUpdate = function() {
        return _this.visit(node.update);
      };
      this.VmLoop(node, emitInit, emitBeforeTest, emitUpdate);
      return node;
    };

    Emitter.prototype.ForInStatement = function(node) {
      var pushIterator,
        _this = this;
      pushIterator = function() {
        return _this.ENUMERATE();
      };
      this.VmIteratorLoop(node, pushIterator);
      return node;
    };

    Emitter.prototype.ForOfStatement = function(node) {
      var pushIterator,
        _this = this;
      pushIterator = function() {
        return _this.ITER();
      };
      this.VmIteratorLoop(node, pushIterator);
      return node;
    };

    Emitter.prototype.ExpressionStatement = function(node) {
      Emitter.__super__.ExpressionStatement.call(this, node);
      this.SREXP();
      return node;
    };

    Emitter.prototype.IfStatement = function(node) {
      var end, ifTrue;
      ifTrue = this.newLabel();
      end = this.newLabel();
      this.visit(node.test);
      this.JMPT(ifTrue);
      this.visit(node.alternate);
      this.JMP(end);
      ifTrue.mark();
      this.visit(node.consequent);
      end.mark();
      return node;
    };

    Emitter.prototype.LabeledStatement = function(node) {
      var brk;
      brk = this.newLabel();
      this.pushLabel(node.label.name, node.body, brk);
      this.visit(node.body);
      brk.mark();
      this.popLabel();
      return node;
    };

    Emitter.prototype.BreakStatement = function(node) {
      var cleanup, label, _i, _len, _ref;
      if (node.label) {
        label = this.label(node.label.name);
        if (label.cleanup) {
          _ref = label.cleanup;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            cleanup = _ref[_i];
            cleanup(label, true);
          }
        }
      } else {
        label = this.label();
      }
      this.JMP(label.brk);
      return node;
    };

    Emitter.prototype.ContinueStatement = function(node) {
      var cleanup, label, _i, _len, _ref;
      if (node.label) {
        label = this.label(node.label.name);
        if (label.cleanup) {
          _ref = label.cleanup;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            cleanup = _ref[_i];
            cleanup(label, false);
          }
        }
      } else {
        label = this.label();
      }
      this.JMP(label.cont);
      return node;
    };

    Emitter.prototype.WithStatement = function(node) {
      this.visit(node.object);
      this.ENTER_WITH();
      this.withLevel++;
      this.visit(node.body);
      this.withLevel--;
      this.EXIT_SCOPE();
      return node;
    };

    Emitter.prototype.SwitchStatement = function(node) {
      var brk, clause, nextBlock, nextTest, _i, _len, _ref,
        _this = this;
      brk = this.newLabel();
      this.pushLabel(null, node, brk);
      this.addCleanupHook((function() {
        _this.POP();
        return _this.exitScope();
      }));
      this.enterScope();
      this.visit(node.discriminant);
      nextBlock = this.newLabel();
      _ref = node.cases;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        clause = _ref[_i];
        nextTest = this.newLabel();
        if (clause.test) {
          this.DUP();
          this.visit(clause.test);
          this.CID();
          this.JMPF(nextTest);
          this.JMP(nextBlock);
        }
        if (clause.consequent.length) {
          nextBlock.mark();
          this.visit(clause.consequent);
          nextBlock = this.newLabel();
          this.JMP(nextBlock);
        }
        nextTest.mark();
      }
      nextBlock.mark();
      this.popLabel();
      brk.mark();
      this.POP();
      this.exitScope();
      return node;
    };

    Emitter.prototype.ReturnStatement = function(node) {
      if (node.argument) {
        this.visit(node.argument);
        this.RETV();
      } else {
        this.RET();
      }
      return node;
    };

    Emitter.prototype.ThrowStatement = function(node) {
      Emitter.__super__.ThrowStatement.call(this, node);
      this.THROW();
      return node;
    };

    Emitter.prototype.TryStatement = function(node) {
      var end, finalizer, guard, guardId, handler, hook, start, _i, _len, _ref,
        _this = this;
      if (node.handlers.length > 1) {
        throw new Error('assert error');
      }
      this.tryStatements.push({
        hooks: []
      });
      start = this.newLabel();
      handler = this.newLabel();
      finalizer = this.newLabel();
      end = this.newLabel();
      guard = {
        start: start,
        handler: node.handlers.length ? handler : null,
        finalizer: node.finalizer ? finalizer : null,
        end: end
      };
      this.guards.push(guard);
      guardId = this.guards.length - 1;
      this.ENTER_GUARD(guardId);
      start.mark();
      this.visit(node.block);
      this.JMP(finalizer);
      handler.mark();
      if (node.handlers.length) {
        node.handlers[0].body.blockInit = function() {
          var assign, hook, param, _i, _len, _ref, _results;
          param = node.handlers[0].param;
          _this.declarePattern(param);
          assign = {
            type: 'ExpressionStatement',
            expression: {
              loc: param.loc,
              type: 'AssignmentExpression',
              operator: '=',
              left: param
            }
          };
          _this.visit(assign);
          _ref = _this.tryStatements[_this.tryStatements.length - 1].hooks;
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            hook = _ref[_i];
            _results.push(hook());
          }
          return _results;
        };
        this.visit(node.handlers[0].body);
      }
      finalizer.mark();
      if (node.finalizer) {
        this.visit(node.finalizer);
        if (!node.handlers.length) {
          _ref = this.tryStatements[this.tryStatements.length - 1].hooks;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            hook = _ref[_i];
            hook();
          }
          this.EXIT_GUARD(guardId);
          this.PAUSE();
        }
      }
      end.mark();
      this.EXIT_GUARD(guardId);
      this.tryStatements.pop();
      return node;
    };

    Emitter.prototype.DebuggerStatement = function(node) {
      this.DEBUG();
      return node;
    };

    Emitter.prototype.VariableDeclaration = function(node) {
      var decl, _i, _len, _ref;
      _ref = node.declarations;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        decl = _ref[_i];
        decl.kind = node.kind;
      }
      this.visit(node.declarations);
      return node;
    };

    Emitter.prototype.VariableDeclarator = function(node) {
      var assign;
      this.declarePattern(node.id, node.kind);
      if (node.init) {
        assign = {
          type: 'ExpressionStatement',
          expression: {
            loc: node.loc,
            type: 'AssignmentExpression',
            operator: '=',
            left: node.id,
            right: node.init
          }
        };
        this.visit(assign);
      }
      return node;
    };

    Emitter.prototype.ThisExpression = function(node) {
      if (this.scopes.length) {
        this.scopeGet('this');
      } else {
        this.GLOBAL();
      }
      return node;
    };

    Emitter.prototype.ArrayExpression = function(node) {
      Emitter.__super__.ArrayExpression.call(this, node);
      this.ARRAY_LITERAL(node.elements.length);
      return node;
    };

    Emitter.prototype.ObjectExpression = function(node) {
      var property, _i, _len, _ref;
      _ref = node.properties;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        property = _ref[_i];
        if (property.kind === 'init') {
          this.visit(property.value);
          if (property.key.type === 'Literal') {
            this.visit(property.key);
          } else {
            this.visit({
              type: 'Literal',
              value: property.key.name
            });
          }
        } else {
          throw new Error("property kind '" + property.kind + "' not implemented");
        }
      }
      this.OBJECT_LITERAL(node.properties.length);
      return node;
    };

    Emitter.prototype.VmFunction = function(node) {
      var ecol, eline, emit, functionIndex, name, scol, sline, source, _ref, _ref1, _ref2,
        _this = this;
      _ref = node.loc, (_ref1 = _ref.start, sline = _ref1.line, scol = _ref1.column), (_ref2 = _ref.end, eline = _ref2.line, ecol = _ref2.column);
      source = this.original.slice(sline - 1, eline);
      source[0] = source[0].slice(scol);
      source[source.length - 1] = source[source.length - 1].slice(0, ecol);
      source = source.join('\n');
      name = '<anonymous>';
      if (node.id) {
        name = node.id.name;
      }
      emit = function() {
        var declaration, declarator, def, fn, i, initialScope, len, param, scope, _i;
        initialScope = {
          "this": 0,
          "arguments": 1
        };
        if (node.id) {
          initialScope[name] = 2;
        }
        if (node.lexicalThis) {
          delete initialScope["this"];
        }
        fn = new Emitter([initialScope].concat(_this.scopes), _this.filename, name, _this.original, source);
        fn.FUNCTION_SETUP(node.id != null);
        len = node.params.length;
        if (node.rest) {
          fn.declareVar(node.rest.name);
          scope = fn.scope(node.rest.name);
          fn.REST(len, scope[1]);
        }
        for (i = _i = 0; 0 <= len ? _i < len : _i > len; i = 0 <= len ? ++_i : --_i) {
          param = node.params[i];
          def = node.defaults[i];
          declaration = parse("var placeholder = arguments[" + i + "] || 0;").body[0];
          declarator = declaration.declarations[0];
          declarator.id = param;
          if (def) {
            declarator.init.right = def;
          } else {
            declarator.init = declarator.init.left;
          }
          fn.visit(declaration);
        }
        if (node.expression) {
          fn.visit(node.body);
          fn.RETV();
        } else {
          fn.visit(node.body.body);
        }
        return fn.end();
      };
      functionIndex = this.scripts.length;
      this.scripts.push(emit);
      if (node.isExpression) {
        this.FUNCTION(functionIndex, node.generator);
      }
      if (node.declare) {
        this.declareFunction(node.declare, functionIndex, node.generator);
      }
      return node;
    };

    Emitter.prototype.FunctionDeclaration = function(node) {
      node.isExpression = false;
      node.declare = node.id.name;
      this.VmFunction(node);
      return node;
    };

    Emitter.prototype.FunctionExpression = function(node) {
      node.isExpression = true;
      node.declare = false;
      this.VmFunction(node);
      return node;
    };

    Emitter.prototype.ArrowFunctionExpression = function(node) {
      node.isExpression = true;
      node.declare = false;
      node.lexicalThis = true;
      this.VmFunction(node);
      return node;
    };

    Emitter.prototype.SequenceExpression = function(node) {
      var i, _i, _ref;
      for (i = _i = 0, _ref = node.expressions.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.visit(node.expressions[i]);
        this.POP();
      }
      this.visit(node.expressions[i]);
      return node;
    };

    Emitter.prototype.UnaryExpression = function(node) {
      if (node.operator === 'delete') {
        if (node.argument.type === 'MemberExpression') {
          this.visitProperty(node.argument);
          this.visit(node.argument.object);
          this.DEL();
        } else if (node.argument.type === 'Identifier' && !this.scopes.length) {
          this.LITERAL(node.argument.name);
          this.GLOBAL();
          this.DEL();
        } else {
          this.LITERAL(false);
        }
      } else {
        if (node.operator === 'typeof' && node.argument.type === 'Identifier') {
          this.ignoreNotDefined = 1;
        }
        Emitter.__super__.UnaryExpression.call(this, node);
        this[unaryOp[node.operator]]();
      }
      return node;
    };

    Emitter.prototype.BinaryExpression = function(node) {
      Emitter.__super__.BinaryExpression.call(this, node);
      this[binaryOp[node.operator]]();
      return node;
    };

    Emitter.prototype.LogicalExpression = function(node) {
      var evalEnd;
      evalEnd = this.newLabel();
      this.visit(node.left);
      this.DUP();
      if (node.operator === '||') {
        this.JMPT(evalEnd);
      } else {
        this.JMPF(evalEnd);
      }
      this.POP();
      this.visit(node.right);
      evalEnd.mark();
      return node;
    };

    Emitter.prototype.ConditionalExpression = function(node) {
      this.IfStatement(node);
      return node;
    };

    Emitter.prototype.NewExpression = function(node) {
      this.visit(node["arguments"]);
      this.visit(node.callee);
      this.NEW(node["arguments"].length);
      return node;
    };

    Emitter.prototype.CallExpression = function(node) {
      var fname, len;
      len = node["arguments"].length;
      this.visit(node["arguments"]);
      if (node.callee.type === 'MemberExpression') {
        this.visit(node.callee.object);
        this.SR1();
        this.LR1();
        this.visitProperty(node.callee);
        if (node.callee.property.type === 'Identifier') {
          fname = node.callee.property.name;
        }
        this.CALLM(len, fname);
      } else {
        this.visit(node.callee);
        if (node.callee.type === 'Identifier') {
          fname = node.callee.name;
        }
        this.CALL(len, fname);
      }
      return node;
    };

    Emitter.prototype.visitProperty = function(memberExpression) {
      if (memberExpression.computed) {
        return this.visit(memberExpression.property);
      } else if (memberExpression.property.type === 'Identifier') {
        return this.LITERAL(memberExpression.property.name);
      } else if (memberExpression.property.type === 'Literal') {
        return this.LITERAL(memberExpression.property.value);
      } else {
        throw new Error('invalid assert');
      }
    };

    Emitter.prototype.MemberExpression = function(node) {
      this.visitProperty(node);
      this.visit(node.object);
      this.GET();
      return node;
    };

    Emitter.prototype.AssignmentExpression = function(node) {
      var childAssignment, element, index, property, source, target, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
      if (node.right) {
        if (node.right.type === 'MemberExpression' && !node.right.object) {
          this.visitProperty(node.right);
          this.SWAP();
          this.GET();
        } else {
          this.visit(node.right);
        }
      }
      if ((_ref = node.left.type) === 'ArrayPattern' || _ref === 'ArrayExpression' || _ref === 'ObjectPattern' || _ref === 'ObjectExpression') {
        if ((_ref1 = node.left.type) === 'ArrayPattern' || _ref1 === 'ArrayExpression') {
          index = 0;
          _ref2 = node.left.elements;
          for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
            element = _ref2[_i];
            if (element) {
              this.DUP();
              childAssignment = {
                operator: node.operator,
                type: 'AssignmentExpression',
                left: element,
                right: {
                  type: 'MemberExpression',
                  property: {
                    type: 'Literal',
                    value: index
                  }
                }
              };
              this.visit(childAssignment);
              this.POP();
            }
            index++;
          }
        } else {
          _ref3 = node.left.properties;
          for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
            property = _ref3[_j];
            this.DUP();
            source = property.key;
            target = property.value;
            childAssignment = {
              operator: node.operator,
              type: 'AssignmentExpression',
              left: target,
              right: {
                type: 'MemberExpression',
                computed: true,
                property: {
                  type: 'Literal',
                  value: source.name
                }
              }
            };
            this.visit(childAssignment);
            this.POP();
          }
        }
        return;
      }
      if (node.left.type === 'MemberExpression') {
        this.visitProperty(node.left);
        this.visit(node.left.object);
        this.SR2();
        this.SR1();
        if (node.operator !== '=') {
          this.LR1();
          this.LR2();
          this.GET();
          this[binaryOp[node.operator.slice(0, node.operator.length - 1)]]();
          this.LR1();
          this.LR2();
          this.SET();
        } else {
          this.LR1();
          this.LR2();
          this.SET();
        }
      } else {
        if (node.operator !== '=') {
          this.scopeGet(node.left.name);
          this.SWAP();
          this[binaryOp[node.operator.slice(0, node.operator.length - 1)]]();
        }
        this.scopeSet(node.left.name);
      }
      return node;
    };

    Emitter.prototype.UpdateExpression = function(node) {
      if (node.argument.type === 'MemberExpression') {
        this.visitProperty(node.argument);
        this.visit(node.argument.object);
        this.SR2();
        this.SR1();
        this.LR1();
        this.LR2();
        this.GET();
        this.SR3();
        this.LR3();
        if (node.operator === '++') {
          this.INC();
        } else {
          this.DEC();
        }
        this.LR1();
        this.LR2();
        this.SET();
      } else {
        this.scopeGet(node.argument.name);
        this.SR3();
        this.LR3();
        if (node.operator === '++') {
          this.INC();
        } else {
          this.DEC();
        }
        this.scopeSet(node.argument.name);
      }
      if (!node.prefix) {
        this.POP();
        this.LR3();
      }
      return node;
    };

    Emitter.prototype.Identifier = function(node) {
      this.scopeGet(node.name);
      return node;
    };

    Emitter.prototype.Literal = function(node) {
      var id, idx, val;
      val = node.value;
      if (typeof val === 'undefined') {
        this.UNDEF();
      } else if (typeof val === 'string') {
        if (!hasProp(this.stringIds, val)) {
          this.strings.push(val);
          idx = this.strings.length - 1;
          this.stringIds[val] = idx;
        }
        idx = this.stringIds[val];
        this.STRING_LITERAL(idx);
      } else if (val instanceof RegExp) {
        id = Script.regexpToString(val);
        if (!hasProp(this.regexpIds, id)) {
          this.regexps.push(val);
          idx = this.regexps.length - 1;
          this.regexpIds[id] = idx;
        }
        idx = this.regexpIds[id];
        this.REGEXP_LITERAL(idx);
      } else {
        this.LITERAL(val);
      }
      return node;
    };

    Emitter.prototype.YieldExpression = function(node) {
      this.visit(node.argument);
      this.YIELD();
      return node;
    };

    Emitter.prototype.ComprehensionExpression = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.ComprehensionBlock = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.ClassExpression = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.ClassBody = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.ClassDeclaration = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.ClassHeritage = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.ExportBatchSpecifier = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.ExportSpecifier = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.ExportDeclaration = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.ImportSpecifier = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.ImportDeclaration = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.MethodDefinition = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.Property = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.ModuleDeclaration = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.SpreadElement = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.TemplateElement = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.TaggedTemplateExpression = function(node) {
      throw new Error('not implemented');
    };

    Emitter.prototype.TemplateLiteral = function(node) {
      throw new Error('not implemented');
    };

    return Emitter;

  })(Visitor);

  (function() {
    var opcode, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = opcodes.length; _i < _len; _i++) {
      opcode = opcodes[_i];
      _results.push((function(opcode) {
        opcodes[opcode.prototype.name] = opcode;
        opcode.prototype.forEachLabel = function(cb) {
          var i, _j, _ref, _results1;
          if (this.args) {
            _results1 = [];
            for (i = _j = 0, _ref = this.args.length; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
              if (this.args[i] instanceof Label) {
                _results1.push(this.args[i] = cb(this.args[i]));
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          }
        };
        return Emitter.prototype[opcode.prototype.name] = function() {
          var args;
          args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (!args.length) {
            args = null;
          }
          this.instructions.push(new opcode(args));
        };
      })(opcode));
    }
    return _results;
  })();

  Label = (function() {
    Label.id = 1;

    function Label(emitter) {
      this.emitter = emitter;
      this.id = Label.id++;
      this.ip = null;
    }

    Label.prototype.mark = function() {
      return this.ip = this.emitter.instructions.length;
    };

    return Label;

  })();

  GETL = opcodes.GETL, SETL = opcodes.SETL, GETG = opcodes.GETG, SETG = opcodes.SETG, FUNCTION = opcodes.FUNCTION, POP = opcodes.POP;

  unaryOp = {
    '-': 'INV',
    '!': 'LNOT',
    '~': 'NOT',
    'typeof': 'TYPEOF',
    'void': 'VOID'
  };

  binaryOp = {
    '==': 'CEQ',
    '!=': 'CNEQ',
    '===': 'CID',
    '!==': 'CNID',
    '<': 'LT',
    '<=': 'LTE',
    '>': 'GT',
    '>=': 'GTE',
    '<<': 'SHL',
    '>>': 'SAR',
    '>>>': 'SHR',
    '+': 'ADD',
    '-': 'SUB',
    '*': 'MUL',
    '/': 'DIV',
    '%': 'MOD',
    '|': 'OR',
    '&': 'AND',
    '^': 'XOR',
    'in': 'IN',
    'instanceof': 'INSTANCEOF'
  };

  assignOp = {
    '+=': 'ADD',
    '-=': 'SUB',
    '*=': 'MUL',
    '/=': 'DIV',
    '%=': 'MOD',
    '<<=': 'SHL',
    '>>=': 'SAR',
    '>>>=': 'SHR',
    '|=': 'OR',
    '&=': 'AND',
    '^=': 'XOR'
  };

  module.exports = Emitter;

}).call(this);


//@ sourceMappingURL=emitter.js.map